{
  "version": 1,
  "title": "Exercise 4",
  "description": "See cg1.oglaroon.cc/exercise4 for the corresponding exercise.",
  "programs": [
    {
      "version": 1,
      "name": "Contour Shader",
      "vertex": "#version 100\n\nattribute vec3 v_Position;\nattribute vec3 v_Normal;\n\nuniform mat4 modelViewProjection;\n\n// uniform thickness parameter wrapped into a material struct\n// this is provided by the models.Material class in the host code\nuniform struct {\n    float thickness;\n} material;\n\n\nvoid main() {\n    // normally you would have\n    //     gl_Position = modelViewProjection * vec4(v_Position, 1);\n    // here, but we want to scale our mesh in order to have a \"line thickness\".\n    // Simplest way to do this is to move all vertices in the direction of their normals\n    // note that v_Normal is *not* unit length, so we first normalize it and then scale it by\n    // our line thickness factor.\n    gl_Position = modelViewProjection * vec4(v_Position + material.thickness * normalize(v_Normal), 1);\n}",
      "fragment": "#version 100\n\nprecision mediump float;\n\n\nvoid main() {\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}",
      "isDefault": true
    },
    {
      "version": 1,
      "name": "Cel Shader",
      "vertex": "#version 100\n\nattribute vec3 v_Position;\nattribute vec3 v_Normal;\n\nuniform mat4 modelViewProjection;\n\n// uniform parameters wrapped into a light struct\nuniform struct {\n    float theta;\n    float phi;\n} light;\n\nvarying float lambertTerm;\n\nvec3 computeLightDirection() {\n    return vec3(\n        cos(light.phi) * sin(light.theta),\n        cos(light.theta),\n        sin(light.phi) * sin(light.theta)\n\n    );\n}\n\nfloat lambert(vec3 normal, vec3 lightDir) {\n    // TASK: Compute and return the lambert lighting term\n    float cosine = dot(normal, lightDir);\n    float lambert = max(cosine, 0.0);\n    return lambert;\n}\n\nvoid main() {\n    gl_Position = modelViewProjection * vec4(v_Position, 1);\n    vec3 ldir = computeLightDirection();\n    vec3 nrm = normalize(v_Normal);\n\n    lambertTerm = lambert(nrm, ldir);\n}",
      "fragment": "#version 100\n\nprecision mediump float;\n\n// uniform parameters wrapped into a material struct\n// this is provided by the models.Material class in the host code\nuniform struct {\n    float steps;\n    vec4 baseColor;\n    float highlight;\n} material;\n\nvarying float lambertTerm;\n\nfloat discretize(float value) {\n    // get the steps as an integer of data type float\n    float steps = floor(material.steps);\n    // TASK: Compute the stepwise light color as described in the exercise\n    return floor(value*steps) / steps;\n}\n\nvoid main() {\n    // get discretized value of our cos(theta)\n    float d = discretize(lambertTerm);\n    // we scale our base color by our discretized factor\n    // additionally we add a highlight white color weighted by our highlight factor\n    // as well as d^3 in order to have some exponential behaviour of our highlight spot\n    // (note that physically this makes no sense, but since we do \"non-realistic rendering\"\n    // here we might as well utilize some dirty hacks...\n    gl_FragColor.rgb = d * material.baseColor.rgb + material.highlight * pow(d, 3.0) * vec3(1.0);\n\n    // adding the highlight white color might yield color values outside the allowed\n    // [0,1] range. Whether or not the GPU automagically clamps these after the fragment shader\n    // is left open to the driver implementation so we go the safe route here and clamp the values ourselves.\n    gl_FragColor.rgb = clamp(gl_FragColor.rgb, 0.0, 1.0);\n\n    // No transparency\n    gl_FragColor.a = 1.0;\n}",
      "isDefault": false
    }
  ],
  "javascript": "function ui(c) {\n    var ui = c.ui;\n\n    // add left hand side grid\n    ui.add(ui.grid({\n        children: [\n            // theta slider in range [0, pi]\n            ui.label({ value: 'Light (Theta Angle):', title: 'Theta Light Angle' }),\n            ui.slider({\n                bind: [this.light, 'theta'],\n                min: 0.0,\n                max: Math.PI\n            }),\n            // phi slider in range [0, 2pi]\n            ui.label({ value: 'Light (Phi Angle):', title: 'Phi Light Angle' }),\n            ui.slider({\n                bind: [this.light, 'phi'],\n                min: 0.0,\n                max: 2.0 * Math.PI\n            })\n        ]\n    }), { left: 10, bottom: 6 });\n\n    // add right hand side grid\n    ui.add(ui.grid({\n        children: [\n            // line thickness slider in range [0, 0.1]\n            ui.label({ value: 'Line Thickness:', title: 'Outer Contour Thickness' }),\n            ui.slider({\n                bind: [this.contourMaterial.uniforms, 'thickness'],\n                min: 0.0,\n                max: 0.1\n            }),\n            // discretization steps slider in range [2, 10]\n            // this yields a float so we have to floor it in order to yield an integer later\n            ui.label({ value: 'Color Steps:', title: 'Number of discretization steps' }),\n            ui.slider({\n                bind: [this.celMaterial.uniforms, 'steps'],\n                min: 2,\n                max: 10\n            }),\n            // color button/dialog for the base color of our cell-shaded faces\n            ui.label({ value: 'Base Color:', title: 'Color at brightest step'}),\n            ui.colorPicker({\n                bind: [this.celMaterial.uniforms, 'baseColor']\n            }),\n            // slider for the highlight factor in range [0, 1]\n            ui.label({ value: 'Highlight Factor:', title: 'Factor for additional lighting' }),\n            ui.slider({\n                bind: [this.celMaterial.uniforms, 'highlight'],\n                min: 0.0,\n                max: 1.0\n            })\n        ]\n    }), { right: 10, bottom: 6 });\n}\n\nfunction init(c) {\n    // define a perspective transformation\n    this.view = c.models.View.perspective(c, 45, null, 0.01, 50);\n    // modify view matrix in order to position the camera\n    this.view.transform\n        .rotateY(-Math.PI / 6)\n        .rotateX(-Math.PI / 6)\n        .translateForward(5);\n\n    // here we load one of the models the playground provides us with\n    //var mesh = \"buddha.obj\";\n    var mesh = \"suzanne.obj\";\n    //var mesh = \"dragon.obj\";\n    //var mesh = \"bunny.obj\";\n    //var mesh = \"teapot.obj\";\n    this.mesh = c.models.Model.load(c, mesh);\n\n    // define the material for the front-facing cell shaded triangles\n    this.celMaterial = new c.models.Material({ steps: 4, baseColor: c.math.vec4(1.0, 0.8, 0.5, 1.0), highlight: 0.5 });\n    this.celMaterial.program = 'Cel Shader';\n\n    // define the material for the back-facing scaled, black faces\n    this.contourMaterial = new c.models.Material({ thickness: 0.01 });\n    this.contourMaterial.program = 'Contour Shader';\n\n    // default values for the light direction\n    this.light = { theta: 1.0, phi: 0.6 }\n    ui.call(this, c);\n}\n\nfunction render(c) {\n    // only draw back-facing triangles\n    this.view.cull = { face: c.gl.FRONT, direction: c.gl.CCW };\n    c.view(this.view);\n\n    // render with contour material and therefore shader\n    this.mesh.render(c, {\n        material: this.contourMaterial\n    });\n\n    // only draw front-facing triangles\n    this.view.cull = { face: c.gl.BACK, direction: c.gl.CCW };\n    c.view(this.view);\n\n    // render with contour material and therefore shader\n    this.mesh.render(c, {\n        material: this.celMaterial,\n        uniforms: {\n            'light.theta': this.light.theta,\n            'light.phi': this.light.phi\n        }\n    });\n}",
  "creationTime": "2015-05-08T07:12:17.441Z",
  "authors": [
    {
      "name": "richard",
      "license": "CC 0",
      "year": 2015
    }
  ]
}