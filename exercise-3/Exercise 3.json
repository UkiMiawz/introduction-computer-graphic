{
  "version": 1,
  "title": "Exercise 3",
  "description": "See cg1.oglaroon.cc/exercise3 for the corresponding exercise.",
  "programs": [
    {
      "version": 1,
      "name": "Default",
      "vertex": "#version 100\n\nattribute vec3 v_Position;\n// uncomment the next line to define the new color attribute\nattribute vec4 v_Color;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec4 f_Color;\n\nvoid main() {\n    gl_Position = projection * modelview * vec4(v_Position, 1);\n    // remove constant color in order to pass correct values\n    // this is just written this way in order to for the example to render anything\n    //f_Color = vec4(0.0, 0.5, 1.0, 1.0);//v_Color;\n    f_Color = v_Color;\n}",
      "fragment": "#version 100\n\nprecision mediump float;\n\nvarying vec4 f_Color;\n\n// the following definition of pi can be used for the color conversion below\n//const float pi = 3.14159265359;\n\n\nvec4 hsva2rgba(vec4 hsva) {\n    // TODO\n    // we directly return here in order to be able to render RGB colors without\n    // changing the code structure - for task 1 you can leave this as it is.\n    // For task 2 however you will need to implement a HSV(A) -> RGB(A)\n    // color conversion here (just copy the alpha channel)\n\n    // Hint: You can access single channels via hsva.r, hsva.g, hsva.b and hsva.a here.\n    // This is because OpenGL by itself only supports rgba colors. Alternatively .x, .y, .z and .w\n    // yield the same result.\n\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsva.xxx + K.xyz) * 6.0 - K.www);\n    vec3 rgb = hsva.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsva.y);\n    vec4 rgba = vec4(rgb, hsva.a);\n    return rgba;\n}\n\n\nvoid main() {\n    gl_FragColor = hsva2rgba(f_Color);\n}",
      "isDefault": true
    }
  ],
  "javascript": "// this definition of pi might come in handy if you want to specify HSV values\n// as Hue is usually in the range (0, 2*pi).\nvar pi = Math.PI;\n\nfunction getTriangleBuffers(c) {\n    triangleVertexPositionBuffer = c.gl.createBuffer();\n    c.gl.bindBuffer(c.gl.ARRAY_BUFFER, triangleVertexPositionBuffer);\n    var vertices = [\n        0.0,  1.0,  0.0,\n        -1.0, -1.0,  0.0,\n        1.0, -1.0,  0.0\n    ];\n    c.gl.bufferData(c.gl.ARRAY_BUFFER, new Float32Array(vertices), c.gl.STATIC_DRAW);\n    triangleVertexPositionBuffer.itemSize = 3;\n    triangleVertexPositionBuffer.numItems = 3;\n\n    triangleVertexColorBuffer = c.gl.createBuffer();\n    // TODO\n    // Define triangle color vertex data like done for positions above\n    c.gl.bindBuffer(c.gl.ARRAY_BUFFER, triangleVertexColorBuffer);\n    var colors = [\n        0.0,  0.0,  0.5, 1.0,\n        0.0,  1.0,  1.0, 1.0,\n        0.0,  1.0,  1.0, 1.0\n    ];\n    c.gl.bufferData(c.gl.ARRAY_BUFFER, new Float32Array(colors), c.gl.STATIC_DRAW);\n    triangleVertexColorBuffer.itemSize = 4;\n\n    // we return both buffers in a struct in order to access both via\n    // .positions and .colors members\n    return {\n        positions: triangleVertexPositionBuffer,\n        colors: triangleVertexColorBuffer\n    };\n}\n\nfunction getSquareBuffers(c) {\n    squareVertexPositionBuffer = c.gl.createBuffer();\n    c.gl.bindBuffer(c.gl.ARRAY_BUFFER, squareVertexPositionBuffer);\n    var vertices = [\n         1.0,  1.0,  0.0,\n        -1.0,  1.0,  0.0,\n         1.0, -1.0,  0.0,\n        -1.0, -1.0,  0.0\n    ];\n    c.gl.bufferData(c.gl.ARRAY_BUFFER, new Float32Array(vertices), c.gl.STATIC_DRAW);\n    squareVertexPositionBuffer.itemSize = 3;\n    squareVertexPositionBuffer.numItems = 4;\n\n    squareVertexColorBuffer = c.gl.createBuffer();\n    // TODO\n    // do the same as in getTriangleBuffers above but for the square.\n    c.gl.bindBuffer(c.gl.ARRAY_BUFFER, squareVertexColorBuffer);\n    var colors = [\n        0.0, 1.0,  1.0, 1.0,\n        1.0, 1.0,  1.0, 1.0,\n        0.0, 1.0,  1.0, 1.0,\n        1.0, 1.0,  1.0, 1.0\n    ];\n    c.gl.bufferData(c.gl.ARRAY_BUFFER, new Float32Array(colors), c.gl.STATIC_DRAW);\n    squareVertexColorBuffer.itemSize = 4;\n\n    return {\n        positions: squareVertexPositionBuffer,\n        colors: squareVertexColorBuffer\n    };\n}\n\nfunction init(c) {\n    // vertex buffer data\n    this.triangle = getTriangleBuffers(c);\n    this.square = getSquareBuffers(c);\n\n    // init GL render state\n    c.gl.clearColor(0.0, 0.0, 0.0, 1.0);\n}\n\nfunction render(c) {\n    // set 'Default' as current shader program\n    c.gl.useProgram(c.programs.Default.program);\n\n    // get locations of uniforms/attributes and enable the latter\n    var prLocation = c.gl.getUniformLocation(c.programs.Default.program, \"projection\");\n    var mvLocation = c.gl.getUniformLocation(c.programs.Default.program, \"modelview\");\n    var posLocation = c.gl.getAttribLocation(c.programs.Default.program, \"v_Position\");\n    c.gl.enableVertexAttribArray(posLocation);\n    // TODO\n    // you will need the location of the color attribute shader variable (like for position above)\n    // and enable this vertex attribute\n    var posColor = c.gl.getAttribLocation(c.programs.Default.program, \"v_Color\");\n    c.gl.enableVertexAttribArray(posColor);\n\n    // get canvas dimensions\n    var w = c.gl.canvas.clientWidth;\n    var h = c.gl.canvas.clientHeight;\n\n    // init projection matrix\n    var pr = c.math.mat4.create();\n    c.math.mat4.perspective(pr, 45 * Math.PI / 180.0, w / h, 0.1, 100.0);\n    c.gl.uniformMatrix4fv(prLocation, false, pr);\n\n    // init modelview matrix\n    var mv = c.math.mat4.create();\n    c.math.mat4.identity(mv);\n\n    // clear framebuffer\n    c.gl.viewport(0, 0, w, h);\n    c.gl.clear(c.gl.COLOR_BUFFER_BIT);\n\n    // render triangle\n    c.math.mat4.translate(mv, mv, [-1.5, 0.0, -7.0]);\n    c.gl.uniformMatrix4fv(mvLocation, false, mv);\n    c.gl.bindBuffer(c.gl.ARRAY_BUFFER, this.triangle.positions);\n    c.gl.vertexAttribPointer(posLocation, this.triangle.positions.itemSize, c.gl.FLOAT, false, 0, 0);\n    // TODO\n    // bind new color buffer and assign it to the v_Color variable location\n    c.gl.bindBuffer(c.gl.ARRAY_BUFFER, this.triangle.colors);\n    c.gl.vertexAttribPointer(posColor, this.triangle.colors.itemSize, c.gl.FLOAT, false, 0, 0);\n    c.gl.drawArrays(c.gl.TRIANGLES, 0, this.triangle.positions.numItems);\n\n    // render square\n    c.math.mat4.translate(mv, mv, [3.0, 0.0, 0.0]);\n    c.gl.uniformMatrix4fv(mvLocation, false, mv);\n    c.gl.bindBuffer(c.gl.ARRAY_BUFFER, this.square.positions);\n    c.gl.vertexAttribPointer(posLocation, this.square.positions.itemSize, c.gl.FLOAT, false, 0, 0);\n    // TODO\n    // same as above but for the square\n    c.gl.bindBuffer(c.gl.ARRAY_BUFFER, this.square.colors);\n    c.gl.vertexAttribPointer(posColor, this.square.colors.itemSize, c.gl.FLOAT, false, 0, 0);\n    c.gl.drawArrays(c.gl.TRIANGLE_STRIP, 0, this.square.positions.numItems);\n}",
  "creationTime": "2015-04-15T15:17:40.015Z",
  "authors": [
    {
      "name": "ich",
      "license": "CC BY",
      "year": 2015
    },
    {
      "name": "richard",
      "license": "CC 0",
      "year": 2015
    }
  ]
}