{
  "version": 1,
  "title": "Exercise 6",
  "description": "Siehe cg1.oglaroon.cc/exercises",
  "programs": [
    {
      "version": 1,
      "name": "Default",
      "vertex": "#version 100\n\nattribute vec3 v_Position;\nattribute vec3 v_Normal;\n\nuniform mat4 modelViewProjection;\nuniform mat3 normalMatrix;\n\nuniform vec3 lightDir;\n\nvarying vec3 normal;\nvarying vec3 light;\n\nvoid main() {\n    gl_Position = modelViewProjection * vec4(v_Position, 1);\n    // normal und light sind die Normal sowie Richtung zum Licht im Eye-Space\n    normal = normalize(normalMatrix * v_Normal);\n    light = normalize(normalMatrix * lightDir);\n}",
      "fragment": "#version 100\n\nprecision mediump float;\n\n// this one depends on the \"Diffuse Model\" button in the rendering view\nuniform bool useOrenNayar;\n\nuniform struct {\n    float roughness; // sigma\n    float refractionIndex;\n    vec4 diffuse; // diffuse part as color\n    vec4 specular; // specular part as color\n} material;\n\nvarying vec3 normal;\nvarying vec3 light;\n\nconst float pi = 3.14159265359;\n\n// Syntatic sugar. We want to clamp all dot products\nfloat cdot(vec3 a, vec3 b) {\n    return clamp(dot(a,b), 0.0, 1.0);\n}\n\n// D\nfloat beckmannDistribution(float dotNH) {\n    float sigma2 = material.roughness * material.roughness;\n    // TASK:\n    // compute the d-term\n    float alpha = acos(dotNH);\n    float cos4alpha = (3.0 + 4.0*cos(2.0*alpha)+ cos(4.0*alpha)) / 8.0;\n    float divider = pi * sigma2 * cos4alpha;\n    float tan2alpha = (1.0 - cos(2.0*alpha)) / (1.0 + cos(2.0*alpha));\n    float upper = exp(-(tan2alpha)/sigma2);\n    float d = upper / divider;\n    return d;\n}\n\n// F\nfloat schlickApprox(float dotVH, float n1, float n2) {\n    // TASK:\n    // compute the f-term\n    float Ro = pow((n1 - n2) / (n1 + n2), 2.0);\n    float f = Ro + (1.0 - Ro)*pow((1.0 - dotVH), 5.0);\n    return f;\n}\n\n// G\nfloat geometricAttenuation(float dotNH, float dotVN, float dotVH, float dotNL) {\n    // TASK:\n    // compute the g-term\n    float VN = (2.0 * dotNH * dotVN) / dotVH;\n    float LN = (2.0 * dotNH * dotNL) / dotVH;\n    float g = min(1.0, min(LN, VN));\n    return g;\n}\n\nfloat cooktorranceTerm(vec3 n, vec3 l) {\n    vec3 v = vec3(0.0, 0.0, 1.0); // in eye space direction to the viewer is simply the z-axis\n    vec3 h = normalize(l + v); // halfangle-vector between V and L\n\n    // in order to avoid redundant computations of some dot product terms we precompute those here...\n    float dotVN = cdot(v, n);\n    float dotNL = cdot(n, l);\n    float dotNH = cdot(n, h);\n    float dotVH = cdot(v, h);\n\n    float D = beckmannDistribution(dotNH);\n    float F = schlickApprox(dotVH, 1.0, material.refractionIndex);\n    float G = geometricAttenuation(dotNH, dotVN, dotVH, dotNL);\n\n    return D * F * G / (4.0 * dotVN * dotNL);\n}\n\nfloat orennayarTerm(float lambert, vec3 n, vec3 l) {\n    vec3 v = vec3(0.0, 0.0, 1.0); // in eye space direction to the viewer is simply the z-axis\n    float sigma2 = material.roughness * material.roughness; // sigma^2\n    // TASK:\n    // implement the oren-nayar reflection model\n    float NdotL = dot(n, l);\n    float NdotV = dot(n, v);\n\n    float angleVN = acos(NdotV);\n    float angleLN = acos(NdotL);\n\n    float alpha = max(angleVN, angleLN);\n    float beta = min(angleVN, angleLN);\n    float gamma = dot(v - n * dot(v, n), l - n * dot(l, n));\n\n    float A = 1.0 - 0.5 * (sigma2 / (sigma2 + 0.57));\n    float B = 0.45 * (sigma2 / (sigma2 + 0.09));\n    float C = sin(alpha) * tan(beta);\n\n    float oren = max(0.0, NdotL) * (A + B * max(0.0, gamma) * C);\n\n    return oren;\n}\n\nvoid main() {\n    // lambertian reflection\n    float lambertTerm = cdot(normal, light);\n    // define diffuse part to be lambertian - unless we choose oren-nayar:\n    // In the latter case compute oren-nayar using the lambert term and choose this as diffuse part.\n    float diffuseTerm = lambertTerm;\n    if (useOrenNayar) {\n        diffuseTerm = orennayarTerm(lambertTerm, normal, light);\n    }\n    // we compute the cook-torrance term for the specular part\n    float specularTerm = cooktorranceTerm(normal, light);\n    // finally combine diffuse and specular using the material properties in order to yield final color\n    gl_FragColor = vec4(vec3(clamp(material.diffuse * diffuseTerm + material.specular * specularTerm, 0.0, 1.0)), 1);\n}",
      "isDefault": true
    }
  ],
  "javascript": "function ui(c) {\n    var ui = c.ui;\n\n    ui.add(ui.grid({\n        children: [\n            // theta in [0, pi]\n            ui.label({ value: 'Light (Theta Angle):', title: 'Theta Light Angle' }),\n            ui.slider({\n                bind: [this.light, 'theta'],\n                min: 0.0,\n                max: Math.PI\n            }),\n            // phi in [0, 2pi]\n            ui.label({ value: 'Light (Phi Angle):', title: 'Phi Light Angle' }),\n            ui.slider({\n                bind: [this.light, 'phi'],\n                min: 0.0,\n                max: 2.0 * Math.PI\n            })\n        ]\n    }), { left: 10, bottom: 6 });\n\n    ui.add(ui.grid({\n        children: [\n            ui.label({ value: 'Diffuse Model: ', title: 'Select different shading models' }),\n            ui.multiswitch({\n                values: [\"Lambert\", \"Oren-Nayar\"],\n                bind: [this, \"diffuseModel\"]\n            }),\n            ui.label({ value: 'Roughness:', title: 'Oren-Nayar Roughness (Sigma)' }),\n            ui.slider({\n                bind: [this.material.uniforms, 'roughness'],\n                min: 0.1,\n                max: 1.0\n            }),\n            ui.label({ value: 'Refraction Index:', title: 'Refraction Index of Material used in Schlicks Approximation' }),\n            ui.slider({\n                bind: [this.material.uniforms, 'refractionIndex'],\n                min: 0.0,\n                max: 1.0\n            }),\n            ui.label({ value: 'Diffuse Color:', title: 'Reflectance color for diffuse part' }),\n            ui.colorPicker({\n                bind: [this.material.uniforms, 'diffuse']\n            }),\n            ui.label({ value: 'Specular Factor:', title: 'Reflectance color for specular part' }),\n            ui.colorPicker({\n                bind: [this.material.uniforms, 'specular']\n            })\n        ]\n    }), { right: 10, bottom: 6 });\n}\n\nfunction init(c) {\n    this.mesh = c.models.Model.load(c, \"suzanne.obj\");\n\n    this.view = c.models.View.perspective(c, 45, null, 0.01, 50);\n\n    this.view.transform\n        .rotateY(-Math.PI / 6)\n        .rotateX(-Math.PI / 6)\n        .translateForward(3);\n\n    this.light = { theta: 1.0, phi: 0.6 }\n\n    this.material = new c.models.Material({\n        roughness: 0.4,\n        refractionIndex: 0.4,\n        diffuse: c.math.vec4(0.5, 0.5, 0.5, 1.0),\n        specular: c.math.vec4(0.8, 0.8, 0.8, 1.0)\n    });\n    this.diffuseModel = \"Oren-Nayar\";\n    ui.call(this, c);\n}\n\nfunction computeNormalMatrix(c) {\n    V = c.math.mat4.fromTransform$(this.view.originTransform());\n    M = c.math.mat4.create();\n    if (this.mesh.fullTransform) {\n        c.math.mat4.fromTransform(M, this.mesh.fullTransform());\n    } else {\n        c.math.mat4.identity(M);\n    }\n    MV = c.math.mat4.mul$(V, M);\n    N = c.math.mat3.create();\n    c.math.mat3.normalFromMat4(N, MV);\n    return N;\n}\n\nfunction render(c) {\n    c.view(this.view);\n    // compute light direction\n    var lightDir = c.math.vec3(\n        Math.cos(this.light.phi) * Math.sin(this.light.theta),\n        Math.cos(this.light.theta),\n        Math.sin(this.light.phi) * Math.sin(this.light.theta)\n    );\n    // normal matrix is the inverse, transposed modelview matrix\n    var normalMatrix = computeNormalMatrix.call(this, c);\n    var useOrenNayar = this.diffuseModel == \"Oren-Nayar\";\n    this.mesh.render(c, {\n        material: this.material,\n        uniforms: {\n            \"normalMatrix\": normalMatrix,\n            \"lightDir\": lightDir,\n            \"useOrenNayar\": useOrenNayar\n        }\n    });\n}",
  "creationTime": "2015-05-15T09:54:33.508Z",
  "authors": [
    {
      "name": "richard",
      "license": "CC 0",
      "year": 2015
    }
  ]
}