{
  "version": 1,
  "title": "Exercise 2",
  "description": "See cg1.oglaroon.cc/exercise2 for the corresponding exercise.",
  "programs": [
    {
      "version": 1,
      "name": "Default",
      "vertex": "#version 100\n\nattribute vec3 v_Position;\n\nuniform mat4 P; // Projection matrix\nuniform mat4 V; // View matrix\nuniform mat4 M; // Model matrix\n\nvoid main() {\n    gl_Position = P * V * M * vec4(v_Position, 1);\n}\n",
      "fragment": "#version 100\n\nprecision mediump float;\n\nuniform vec4 color;\n\nvoid main() {\n    gl_FragColor = color;\n}\n",
      "isDefault": true
    }
  ],
  "javascript": "// Computes a a 4x4 translation matrix given\n// a 3-dimensional translation vector.\nfunction makeTranslationMatrix(c, translation) {\n    var x = translation[0];\n    var y = translation[1];\n    var z = translation[2];\n\n    var M = c.math.mat4(\n        1, 0, 0, x,\n        0, 1, 0, y,\n        0, 0, 1, z,\n        0, 0, 0, 1\n    );\n\n    // Since we wrote the matrix in the usual mathematical\n    // order (i.e. row-wise) but OpenGL expects column-wise\n    // order, we transpose the matrix here.\n    c.math.mat4.transpose(M, M);\n    return M;\n}\n\n// Computes a 4x4 (uniform) scaling\n// matrix given a scaling factor.\nfunction makeScalingMatrix(c, factor) {\n    var f = factor;\n\n    var M = c.math.mat4(\n        f, 0, 0, 0,\n        0, f, 0, 0,\n        0, 0, f, 0,\n        0, 0, 0, 1\n    );\n\n    return M;\n}\n\n// Computes a 4x4 rotation matrix given a\n// rotation axis and a rotation angle.\nfunction makeRotationMatrix(c, axis, angle) {\n    // Just in case, normalize the given axis vector.\n    c.math.vec3.normalize(axis, axis);\n\n    // TASK:\n    // We use utility functions here to generate a quaternion\n    // representing a rotation around a given axis with a given\n    // angle, and then convert it to a 4x4 matrix. Your task\n    // is to replace the following four lines with a manual\n    // computation of (1) a suitable quaternion (x, y, z, w), and\n    // (2) an explicit conversion of the quaternion to a 4x4 matrix.\n    // If you write the matrix in mathematical order, don't forget\n    // to transpose it before returning it (analogously to the\n    // \"makeTranslationMatrix\" function). You should only use\n    // plain vectors (vec4), matrices (mat4), Math.cos, Math.sin,\n    // and usual scalar multiplication (e.g. 2*x*y).\n\n    var s = Math.sin(angle/2);\n    var qx = axis[0]*s;\n    var qy = axis[1]*s;\n    var qz = axis[2]*s;\n    var qw = Math.cos(angle/2);\n    var q = c.math.vec4(qx, qy, qz, qw);\n\n    //quatrion to matrix 4x4\n    var M_raw = c.math.mat4(\n        1-2*qy*qy-2*qz*qz, 2*qx*qy-2*qz*qw, 2*qx*qz+2*qy*qw, 0,\n        2*qx*qy+2*qz*qw, 1-2*qx*qx-2*qz*qz, 2*qy*qz-2*qx*qw, 0,\n        2*qx*qz-2*qy*qw, 2*qy*qz+2*qx*qw, 1-2*qx*qx-2*qy*qy, 0,\n        0, 0, 0, 1\n    );\n\n    //transpose matrix\n    var M = c.math.mat4(\n        1 - 2*qy*qy - 2*qz*qz, 2*qx*qy + 2*qz*qw, 2*qx*qz - 2*qy*qw, 0,\n        2*qx*qy-2*qz*qw, 1-2*qx*qx-2*qz*qz, 2*qy*qz+2*qx*qw, 0,\n        2*qx*qz+2*qy*qw, 2*qy*qz-2*qx*qw, 1-2*qx*qx-2*qy*qy, 0,\n        0, 0, 0, 1\n     );\n\n    return M;\n}\n\n// Initialization\nfunction init(c) {\n    // Enable depth buffering to make sure parts\n    // of objects behind other objects are hidden.\n    c.gl.enable(c.gl.DEPTH_TEST);\n    // Make a generic sphere for later use.\n    this.sphere = new c.models.IcoSphere(c, 0.2, 4);\n}\n\n// Render function, called each render cycle\nfunction render(c) {\n    // Set up the viewport (i.e. the area\n    // where stuff will be drawn.\n    var w = c.gl.canvas.clientWidth;\n    var h = c.gl.canvas.clientHeight;\n    c.gl.viewport(0, 0, w, h);\n\n    // \"time\" contains a (float) timestamp looping\n    // in the range [0, 2pi). We can use this when\n    // specifying transformations to get animation.\n    var time = (new Date).getTime() / 1000 % (2 * Math.PI);\n\n    // Set up the projection matrix. We use a utility\n    // function to set up a perspective transformation.\n    var P = c.math.mat4.create();\n    c.math.mat4.perspective(P, 45 * Math.PI / 180.0, w / h, 0.1, 100.0);\n\n    // Set up the view matrix. We rotate and translate\n    // the world to get the effect of a camera looking\n    // down at the scene slightly tilted downwards.\n    var V = c.math.mat4.create();\n    c.math.mat4.multiply(V, V, makeTranslationMatrix(c, c.math.vec3(0, 0, -4)));\n    c.math.mat4.multiply(V, V, makeRotationMatrix(c, c.math.vec3(1, 0, 0), 0.7));\n\n    // Set up the first model matrix for rendering the\n    // red \"sun\". We only apply a scaling to it.\n    var M = c.math.mat4.create();\n    c.math.mat4.multiply(M, M, makeScalingMatrix(c, 3.0));\n\n    // Render the sun in red color with the specified\n    // matrices (see vertex and fragment shaders for\n    // how P, V, M, and color are used.\n    c.view(this.view);\n    this.sphere.render(c, {uniforms: {\n        color: c.math.vec4(0.8, 0, 0, 1),\n        P: P, V: V, M: M\n    }});\n\n    // For rendering the green \"planet\", we reset our\n    // matrix first to undo the scaling (you could also\n    // scale it by the inverse factor). Then we apply\n    // a translation and rotation. Note that the rotation\n    // depends on the \"time\" variable.\n    c.math.mat4.identity(M);\n    c.math.mat4.multiply(M, M, makeRotationMatrix(c, c.math.vec3(0, 1, 0), time));\n    c.math.mat4.multiply(M, M, makeTranslationMatrix(c, c.math.vec3(1.2, 0, 0)));\n\n    // Render the planet using the updated model matrix.\n    c.view(this.view);\n    this.sphere.render(c, {uniforms: {\n        color: c.math.vec4(0, 0.8, 0, 1),\n        P: P, V: V, M: M\n    }});\n\n    // TASK:\n    // Render a blue \"moon\" that revolves around the green planet.\n    // The center of revolution shall be located in the center\n    // of the green planet. The moon shall be a little smaller than\n    // the planet. See the exercise description for an example\n    // how the result should look like.\n\n    c.math.mat4.multiply(M, M, makeScalingMatrix(c, 0.5));\n    c.math.mat4.multiply(M, M, makeRotationMatrix(c, c.math.vec3(0, 1, 0), (-time)*4));\n    c.math.mat4.multiply(M, M, makeTranslationMatrix(c, c.math.vec3(1, 0, 0)));\n\n    // Render the planet using the updated model matrix.\n    c.view(this.view);\n    this.sphere.render(c, {uniforms: {\n        color: c.math.vec4(0, 0, 0.8, 1),\n        P: P, V: V, M: M\n    }});\n\n\n}\n",
  "creationTime": "2015-05-04T16:03:55.035Z",
  "authors": [
    {
      "name": "Sebastian",
      "license": "CC BY",
      "year": 2015
    },
    {
      "name": "richard",
      "license": "CC 0",
      "year": 2015
    }
  ]
}