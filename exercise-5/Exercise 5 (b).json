{
  "version": 1,
  "title": "Exercise 5 (b)",
  "description": "For the corresponding exercise see cg1.oglaroon.cc/exercise5",
  "programs": [
    {
      "version": 1,
      "name": "Default",
      "vertex": "#version 100\n\nprecision highp float;\n\nattribute vec3 v_Position;\n\nuniform mat4 modelViewProjection;\n\nuniform vec2 min_coords;\nuniform vec2 max_coords;\n\nvarying vec2 coord;\n\nvoid main() {\n    gl_Position = modelViewProjection * vec4(v_Position, 1);\n    coord = (gl_Position.xy / gl_Position.w);\n    vec2 range = max_coords - min_coords;\n    coord = range * 0.5 * (coord + vec2(1.0)) + min_coords;\n}",
      "fragment": "#version 100\n\nprecision highp float;\n\n// zero crossings of z^4 - 1\nconst vec2 n0 = vec2(-1.0,  0.0);\nconst vec2 n1 = vec2( 1.0,  0.0);\nconst vec2 n2 = vec2( 0.0, -1.0);\nconst vec2 n3 = vec2( 0.0,  1.0);\n\n// maximum |z| threshold for divergence\nuniform float max_value;\n// step-size of the newton-raphson method\nuniform float step_size;\n\n// coordinate between min_coords and max_coords\nvarying vec2 coord;\n\n// maximum iteration count\n// (needs to be constant - if you encounter problems with running this\n// exercise try a lower iteration count like 15)\nconst int max_iterations = 225;\n// distance between z and n{0,1,2,3} for which we assume convergence\nconst float epsilon = 0.01;\n\nconst float pi = 3.14159265359;\n\n\nvec2 cmult(vec2 a, vec2 b) {\n    // TASK: implement complex multiplication\n    // a.x and b.x are real parts, a.y and b.y are imaginary parts\n    vec2 c;\n    c.x = (a.x*b.x) - (a.y*b.y);\n    c.y = (a.x*b.y) + (a.y*b.x);\n    return c;\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    // TASK: implement complex division\n    // a.x and b.x are real parts, a.y and b.y are imaginary parts\n    vec2 c;\n    c.x = ((a.x*b.x) + (a.y*b.y)) / ((b.x*b.x) + (b.y*b.y));\n    c.y = ((a.y*b.x) - (a.x*b.y)) / ((b.x*b.x) + (b.y*b.y));\n    return c;\n}\n\nvec4 hsva2rgba(vec4 hsva) {\n    vec3 hsv = hsva.rgb;\n\n    float c = hsv.g * hsv.b;\n    float h = 3.0 * hsv.r / pi;\n    float x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\n    int q = int(floor(h));\n\n    vec3 rgb = vec3(0.0);\n    if (q == 0) {\n        rgb = vec3(c, x, 0.0);\n    } else if (q == 1) {\n        rgb = vec3(x, c, 0.0);\n    } else if (q == 2) {\n        rgb = vec3(0.0, c, x);\n    } else if (q == 3) {\n        rgb = vec3(0.0, x, c);\n    } else if (q == 4) {\n        rgb = vec3(x, 0.0, c);\n    } else {\n        rgb = vec3(c, 0.0, x);\n    }\n\n    float m = hsv.b - c;\n\n    return vec4(rgb + vec3(m), hsva.a);\n}\n\nvec2 f(vec2 z) {\n    // f(z) = z^4 - 1\n    return cmult(z, cmult(z, cmult(z, z))) - vec2(1.0, 0.0);\n}\n\nvec2 df(vec2 z) {\n    // df(z) = 4z^3\n    vec2 pow3 = cmult(z, cmult(z, z));\n    return 4.0 * pow3;\n}\n\n\nvoid main() {\n    vec2 z = coord;\n\n    int steps = 0;\n    int n = -1;\n    bool diverged = false;\n    for (int i = 0; i < max_iterations; ++i) {\n        if (distance(z, n0) < epsilon) {\n            n = 0;\n            steps = i;\n            break;\n        }\n        if (distance(z, n1) < epsilon) {\n            n = 1;\n            steps = i;\n            break;\n        }\n        if (distance(z, n2) < epsilon) {\n            n = 2;\n            steps = i;\n            break;\n        }\n        if (distance(z, n3) < epsilon) {\n            n = 3;\n            steps = i;\n            break;\n        }\n\n        // divergence assumed iff |z| > max_value\n        if (length(z) > max_value) {\n            diverged = true;\n            break;\n        }\n\n        // Task:\n        // Implement Newton-Raphson iteration with step-size control.\n        z -= cmult(cdiv(f(z),df(z)), vec2(step_size,0));\n    }\n\n    if (diverged) {\n        // diverged -> schwarz\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else if (n < 0) {\n        // not converged in max_iterations steps -> wei√ü\n        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    } else {\n        // color encodes zero-crossing, the more iterations necessary the\n        // darker the color\n        float d = float(steps) / float(max_iterations);\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        float hue = (float(n) / 4.0) * 2.0 * pi;\n        gl_FragColor = hsva2rgba(vec4(hue, 1.0, 1.0-d, 1.0));\n    }\n}",
      "isDefault": true
    }
  ],
  "javascript": "function ui(c) {\n    var ui = c.ui;\n\n    ui.add(ui.grid({\n        children: [\n            ui.label({ value: 'coord_min_x:', title: 'Min X-Coordinate of window' }),\n            ui.slider({\n                bind: [this.min_coords, '0'],\n                min: -1.0,\n                max: 1.0\n            }),\n            ui.label({ value: 'coord_min_y:', title: 'Min Y-Coordinate of window' }),\n            ui.slider({\n                bind: [this.min_coords, '1'],\n                min: -1.0,\n                max: 1.0\n            }),\n            ui.label({ value: 'coord_max_x:', title: 'Max X-Coordinate of window' }),\n            ui.slider({\n                bind: [this.max_coords, '0'],\n                min: 0.0,\n                max: 1.0\n            }),\n            ui.label({ value: 'coord_max_y:', title: 'Max Y-Coordinate of window' }),\n            ui.slider({\n                bind: [this.max_coords, '1'],\n                min: 0.0,\n                max: 1.0\n            })\n        ]\n    }), { left: 10, bottom: 6 });\n\n    ui.add(ui.grid({\n        children: [\n            ui.label({ value: 'max_value:', title: 'Max number of iterations' }),\n            ui.slider({\n                bind: [this, 'max_value'],\n                min: 0.0,\n                max: 50000.0\n            }),\n            ui.label({ value: 'step_size:', title: 'Step size factor' }),\n            ui.slider({\n                bind: [this, 'step_size'],\n                min: 0.02,\n                max: 1.99\n            })\n        ]\n    }), { right: 10, bottom: 6 });\n}\n\nfunction init(c) {\n    // render fullscreen quad\n    this.quad = new c.models.Quad(c, [0,0,0], [1,0,0], [1,1,0], [0,1,0]);\n    // orthographic projection\n    this.view = c.models.View.orthographic(c, null, -1, 1, {\n        interactive: false // disable mouse rotation\n    });\n\n    this.min_coords = c.math.vec2(-1.0, -1.0);\n    this.max_coords = c.math.vec2(1.0, 1.0);\n\n    this.max_value = 35000;\n    this.step_size = 1.7;\n\n    ui.call(this, c);\n}\n\nfunction render(c) {\n    c.view(this.view);\n    this.quad.render(c, {uniforms: { min_coords: this.min_coords, max_coords: this.max_coords, max_value: this.max_value, step_size: this.step_size }});\n}",
  "creationTime": "2015-05-18T13:47:26.543Z",
  "authors": [
    {
      "name": "richard",
      "license": "CC 0",
      "year": 2015
    }
  ]
}