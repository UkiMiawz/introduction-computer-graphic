{
  "version": 1,
  "title": "Exercise 9",
  "description": "Exercise for lesson 9. See cg1.oglaroon.cc.",
  "programs": [
    {
      "version": 1,
      "name": "Rendering Pass",
      "vertex": "#version 100\n\nprecision mediump float;\n\nattribute vec3 v_Position;\nattribute vec3 v_Normal;\n\nuniform mat4 modelView;\nuniform mat4 projection;\n\nvarying vec3 normal;\n\nvoid main() {\n    gl_Position = projection * modelView * vec4(v_Position, 1);\n    normal = (modelView * vec4(v_Normal, 0.0)).xyz;\n}",
      "fragment": "#version 100\n\nprecision mediump float;\n\nvarying vec3 normal;\n\nvoid main() {\n    // write geometric data to g-buffer\n    // note that we shift normal coordinates to [0,1]\n    // (this has to be reversed in the second pass)\n    gl_FragColor = vec4(0.5 * (normalize(normal) + 1.0), gl_FragCoord.z);\n}",
      "isDefault": true
    },
    {
      "version": 1,
      "name": "Compose Pass",
      "vertex": "#version 100\n\nattribute vec3 v_Position;\n\nuniform mat4 modelViewProjection;\nuniform vec2 halfSizeNear;\nuniform mat4 sceneView;\nuniform vec3 lightPos;\n\nvarying vec2 uv;\nvarying vec3 eyeDirection;\nvarying vec3 light;\n\nvoid main() {\n    gl_Position = modelViewProjection * vec4(v_Position, 1);\n    uv.xy = v_Position.xy;\n    // Task:\n    // Compute the eyeDirection (d_eye in the lesson)\n    // using halfSizeNear\n    float d_eye1 = (2.0 * halfSizeNear[0] * uv[0]) - halfSizeNear[0];\n    float d_eye2 = (2.0 * halfSizeNear[1] * uv[1]) - halfSizeNear[0];\n    eyeDirection = vec3(d_eye1, d_eye2, -1.0);\n    light = (sceneView * vec4(lightPos, 1.0)).xyz;\n}",
      "fragment": "#version 100\n\nprecision highp float;\n\n// fixed light parameters\nconst float emission = 600.0;\nconst vec3 ka = vec3(0.05, 0.05, 0.05);\nconst vec3 kd = vec3(0.4, 0.4, 0.4);\nconst vec3 ks = vec3(1.0, 1.0, 1.0);\nconst float alpha = 5.0;\n\nuniform sampler2D sampler;\nuniform mat4 sceneProjection;\n\nvarying vec2 uv;\nvarying vec3 eyeDirection;\nvarying vec3 light;\n\nvec4 getEyePosition(float bufferZ) {\n    // TASK\n    // compute the position in eye-space using bufferZ and sceneProjection\n    float z_ndc = 2.0 * bufferZ - 1.0;\n    float c = sceneProjection[2][3];\n    float a = sceneProjection[2][2];\n    float b = sceneProjection[3][2];\n\n    float z_eye = b / (b * z_ndc - a);\n\n    return vec4(0.0, 0.0, z_eye, 1.0);\n}\n\nvec3 phong(vec3 l, vec3 n) {\n    // simple phong model based on light direction/distance\n    float d = length(l);\n    vec3 ln = l / d;\n    vec3 r = reflect(-ln, n);\n    float intensity = 1.0/(d*d);\n    float diff = clamp(dot(ln,n), 0.0, 1.0);\n    float spec = clamp(pow(clamp(r.z, 0.0, 1.0), alpha), 0.0, 1.0);\n    return ka + (kd * diff + ks * spec) * intensity * emission;\n}\n\nvoid main() {\n    // TASK:\n    // read the normal and z-value from g-buffer\n    // for this pay close attention to how the normal is written in the\n    // first pass!\n    vec4 buffer = gl_FragColor;\n    vec3 normal = vec3(buffer);\n    float fragZ = buffer[3];\n\n    vec3 eyePos = -getEyePosition(fragZ).xyz;\n\n    vec3 color;\n    // we somehow have to distinguish background from scene content.\n    // Since normals should have length 1 we can use this length to distingish\n    // geometry from background...\n    if (length(normal) < 0.5) {\n        // background -> return background color\n        color = vec3(0.6, 0.6, 0.6);\n    } else {\n        // not background -> compute light color\n        color = phong(light - eyePos, normal);\n    }\n\n    gl_FragColor = vec4(color, 1.0);\n}",
      "isDefault": false
    }
  ],
  "javascript": "function extensions(c) {\n    // we want to use floating point values in textures...\n    this.extensions = c.requireExtensions([\n        'OES_texture_float'\n    ]);\n}\n\nfunction ui(c) {\n    var ui = c.ui;\n\n    ui.add(ui.grid({\n        children: [\n            // theta slider in range [0, pi]\n            ui.label({ value: 'Light (Theta Angle):', title: 'Theta Light Angle' }),\n            ui.slider({\n                bind: [this.light, 'theta'],\n                min: 0.0,\n                max: Math.PI\n            }),\n            // phi slider in range [0, 2pi]\n            ui.label({ value: 'Light (Phi Angle):', title: 'Phi Light Angle' }),\n            ui.slider({\n                bind: [this.light, 'phi'],\n                min: 0.0,\n                max: 2.0 * Math.PI\n            }),\n            // radius slider in range [0, 100]\n            ui.label({ value: 'Light (Radius):', title: 'Light Distance' }),\n            ui.slider({\n                bind: [this.light, 'radius'],\n                min: 20.0,\n                max: 40.0\n            })\n        ]\n    }), { left: 10, bottom: 6 });\n}\n\nfunction init(c) {\n    this.view = c.models.View.perspective(c, 45, null, 0.01, 50, {\n        buffer: {color: {texture: {type: c.gl.FLOAT}}}\n    });\n\n    // compute half near plane size\n    var viewport = this.view.currentViewport();\n    var aspect = viewport[2] / viewport[3];\n    var fovy = 45.0 * Math.PI / 180.0;\n    this.halfSizeNear = c.math.vec2(0.0, Math.tan(fovy / 2.0));\n    this.halfSizeNear[0] = aspect * this.halfSizeNear[1];\n\n    // the background color. It is worth noting that this is the content of the\n    // *g-buffer*! Due to the way normals are written this results in writing\n    // \"background normals\" as [0.5 0.5 0.5] which in turn will be [0,0,0] in\n    // the second pass (which we interpret as background there)\n    this.view.color = c.math.vec4(0.5, 0.5, 0.5, 0);\n\n    this.model = c.models.Model.load(c, \"suzanne.obj\");\n    //this.model = new c.models.Box(c, 1, 1, 1);\n\n    var r = -Math.PI / 6;\n    this.view.transform.rotateY(r).rotateX(r).translateForward(3);\n\n    // full screen quad view\n    this.fview = c.models.View.orthographic(c, null, -1, 1, {interactive: false});\n    // fullscreen quad\n    this.quad = new c.models.Quad(c, [0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]);\n    this.quad.material.program = \"Compose Pass\";\n\n    this.light = { theta: 1.0, phi: 0.6, radius: 30.0 }\n\n    ui.call(this, c);\n}\n\nfunction render(c) {\n    // geometry pass\n    c.view(this.view);\n    this.model.render(c);\n\n    // compose pass\n    c.view(this.fview);\n\n    // compute light position\n    var lightPos = c.math.vec3(\n        this.light.radius * Math.cos(this.light.phi) * Math.sin(this.light.theta),\n        this.light.radius * Math.cos(this.light.theta),\n        this.light.radius * Math.sin(this.light.phi) * Math.sin(this.light.theta)\n    );\n\n    // render fullscreen quad\n    var viewMatrix = c.math.mat4.fromTransform(c.math.mat4.create(), this.view.originTransform());\n    this.quad.render(c, {\n        uniforms: {\n            sampler: this.view.activeBufferTexture('color'),\n            halfSizeNear: this.halfSizeNear,\n            sceneProjection: this.view.projection(),\n            sceneView: viewMatrix,\n            lightPos: lightPos\n        }\n    });\n}\n",
  "creationTime": "2014-10-13T17:41:46.792Z",
  "authors": [
    {
      "name": "Jesse van den Kieboom",
      "license": "CC BY",
      "year": 2014
    },
    {
      "name": "richard",
      "license": "CC 0",
      "year": 2016
    }
  ]
}